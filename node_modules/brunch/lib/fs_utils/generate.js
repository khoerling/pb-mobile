// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var SourceMapConsumer, SourceMapGenerator, SourceNode, common, concat, debug, extractOrder, flatten, fs, generate, mapOptimizerChain, optimize, sort, sortAlphabetically, sortBowerComponents, sortByAfter, sortByBefore, sortByConfig, sortByVendor, sysPath, waterfall, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  debug = require('debug')('brunch:generate');

  fs = require('fs');

  sysPath = require('path');

  waterfall = require('async-waterfall');

  common = require('./common');

  _ref = require('source-map'), SourceMapConsumer = _ref.SourceMapConsumer, SourceMapGenerator = _ref.SourceMapGenerator, SourceNode = _ref.SourceNode;

  sortAlphabetically = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };

  sortByVendor = function(config, a, b) {
    var aIsVendor, bIsVendor;
    aIsVendor = config.vendorConvention(a);
    bIsVendor = config.vendorConvention(b);
    if (aIsVendor && !bIsVendor) {
      return -1;
    } else if (!aIsVendor && bIsVendor) {
      return 1;
    } else {
      return sortAlphabetically(a, b);
    }
  };

  sortBowerComponents = function(config, a, b) {
    var aLevel, bLevel;
    aLevel = config.bowerMapping[a];
    bLevel = config.bowerMapping[b];
    if ((aLevel != null) && (bLevel == null)) {
      return -1;
    } else if ((aLevel == null) && (bLevel != null)) {
      return 1;
    } else if ((aLevel != null) && (bLevel != null)) {
      return bLevel - aLevel;
    } else {
      return sortByVendor(config, a, b);
    }
  };

  sortByAfter = function(config, a, b) {
    var hasA, hasB, indexOfA, indexOfB, _ref1;
    indexOfA = config.after.indexOf(a);
    indexOfB = config.after.indexOf(b);
    _ref1 = [indexOfA !== -1, indexOfB !== -1], hasA = _ref1[0], hasB = _ref1[1];
    if (hasA && !hasB) {
      return 1;
    } else if (!hasA && hasB) {
      return -1;
    } else if (hasA && hasB) {
      return indexOfA - indexOfB;
    } else {
      return sortBowerComponents(config, a, b);
    }
  };

  sortByBefore = function(config, a, b) {
    var hasA, hasB, indexOfA, indexOfB, _ref1;
    indexOfA = config.before.indexOf(a);
    indexOfB = config.before.indexOf(b);
    _ref1 = [indexOfA !== -1, indexOfB !== -1], hasA = _ref1[0], hasB = _ref1[1];
    if (hasA && !hasB) {
      return -1;
    } else if (!hasA && hasB) {
      return 1;
    } else if (hasA && hasB) {
      return indexOfA - indexOfB;
    } else {
      return sortByAfter(config, a, b);
    }
  };

  sortByConfig = function(files, config) {
    var cfg, _ref1, _ref2, _ref3, _ref4;
    if (toString.call(config) === '[object Object]') {
      cfg = {
        before: (_ref1 = config.before) != null ? _ref1 : [],
        after: (_ref2 = config.after) != null ? _ref2 : [],
        vendorConvention: (_ref3 = config.vendorConvention) != null ? _ref3 : function() {
          return false;
        },
        bowerMapping: (_ref4 = config.bowerMapping) != null ? _ref4 : {}
      };
      return files.slice().sort(function(a, b) {
        return sortByBefore(cfg, a, b);
      });
    } else {
      return files;
    }
  };

  flatten = function(array) {
    return array.reduce(function(acc, elem) {
      return acc.concat(Array.isArray(elem) ? flatten(elem) : [elem]);
    }, []);
  };

  extractOrder = function(files, config) {
    var after, before, orders, types, vendorConvention;
    types = files.map(function(file) {
      return file.type + 's';
    });
    orders = Object.keys(config.files).filter(function(key) {
      return __indexOf.call(types, key) >= 0;
    }).map(function(key) {
      var _ref1;
      return (_ref1 = config.files[key].order) != null ? _ref1 : {};
    });
    before = flatten(orders.map(function(type) {
      var _ref1;
      return (_ref1 = type.before) != null ? _ref1 : [];
    }));
    after = flatten(orders.map(function(type) {
      var _ref1;
      return (_ref1 = type.after) != null ? _ref1 : [];
    }));
    vendorConvention = config._normalized.conventions.vendor;
    return {
      before: before,
      after: after,
      vendorConvention: vendorConvention,
      bowerMapping: config._normalized.bowerFilesMap
    };
  };

  sort = function(files, config) {
    var indexes, order, paths;
    paths = files.map(function(file) {
      return file.path;
    });
    indexes = Object.create(null);
    files.forEach(function(file, index) {
      return indexes[file.path] = file;
    });
    order = extractOrder(files, config);
    return sortByConfig(paths, order).map(function(path) {
      return indexes[path];
    });
  };

  concat = function(files, path, type, definition) {
    var root;
    root = new SourceNode();
    debug("Concatenating " + (files.map(function(_) {
      return _.path;
    }).join(', ')) + " to " + path);
    files.forEach(function(file) {
      var data;
      root.add(file.node);
      if (type === 'javascript') {
        root.add(';');
      }
      data = file.node.isIdentity ? file.data : file.source;
      return root.setSourceContent(file.node.source, data);
    });
    if (type === 'javascript') {
      root.prepend(definition(path, root.sourceContents));
    }
    return root.toStringWithSourceMap({
      file: path
    });
  };

  mapOptimizerChain = function(optimizer) {
    return function(params, next) {
      var code, data, map, optimizeFn, optimizerArgs, path;
      data = params.data, code = params.code, map = params.map, path = params.path;
      debug("Optimizing '" + path + "' with '" + optimizer.constructor.name + "'");
      optimizeFn = optimizer.optimize || optimizer.minify;
      optimizerArgs = optimizeFn.length === 2 ? [params] : [data, path];
      optimizerArgs.push(function(error, optimized) {
        var json, newMap, optimizedCode, optimizedMap;
        if (error != null) {
          return next(error);
        }
        if (toString.call(optimized) === '[object Object]') {
          optimizedCode = optimized.data;
          optimizedMap = optimized.map;
        } else {
          optimizedCode = optimized;
        }
        if (optimizedMap != null) {
          json = optimizedMap.toJSON();
          newMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(optimizedMap));
          newMap._sources.add(path);
          newMap._mappings.forEach(function(mapping) {
            return mapping.source = path;
          });
          if (newMap._sourcesContents == null) {
            newMap._sourcesContents = {};
          }
          newMap._sourcesContents["$" + path] = '';
          newMap.applySourceMap(smConsumer);
        } else {
          newMap = map;
        }
        return next(error, {
          data: optimizedCode,
          code: optimizedCode,
          map: newMap,
          path: path
        });
      });
      return optimizeFn.apply(optimizer, optimizerArgs);
    };
  };

  optimize = function(data, map, path, optimizers, isEnabled, callback) {
    var first, initial;
    initial = {
      data: data,
      code: data,
      map: map,
      path: path
    };
    if (!isEnabled) {
      return callback(null, initial);
    }
    first = function(next) {
      return next(null, initial);
    };
    return waterfall([first].concat(optimizers.map(mapOptimizerChain)), callback);
  };

  generate = function(path, sourceFiles, config, optimizers, callback) {
    var code, map, mapPath, sorted, type, withMaps, _ref1;
    type = sourceFiles.some(function(file) {
      var _ref1;
      return (_ref1 = file.type) === 'javascript' || _ref1 === 'template';
    }) ? 'javascript' : 'stylesheet';
    optimizers = optimizers.filter(function(optimizer) {
      return optimizer.type === type;
    });
    sorted = sort(sourceFiles, config);
    _ref1 = concat(sorted, path, type, config._normalized.modules.definition), code = _ref1.code, map = _ref1.map;
    withMaps = map && config.sourceMaps;
    mapPath = "" + path + ".map";
    return optimize(code, map, path, optimizers, config.optimize, function(error, data) {
      var base, controlChar;
      if (error != null) {
        return callback(error);
      }
      if (withMaps) {
        base = sysPath.basename(mapPath);
        controlChar = config.sourceMaps === 'old' ? '@' : '#';
        data.code += type === 'javascript' ? "\n//" + controlChar + " sourceMappingURL=" + base : "\n/*" + controlChar + " sourceMappingURL=" + base + "*/";
      }
      return common.writeFile(path, data.code, function() {
        if (withMaps) {
          return common.writeFile(mapPath, data.map.toString(), callback);
        } else {
          return callback();
        }
      });
    });
  };

  generate.sortByConfig = sortByConfig;

  module.exports = generate;

}).call(this);
