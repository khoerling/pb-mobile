// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var SourceNode, applyOverrides, cleanModuleName, commonRequireDefinition, createJoinConfig, debug, deepExtend, deepFreeze, exec, extend, fs, getModuleWrapper, http, identityNode, install, isWindows, logger, normalizeChecker, normalizeConfig, normalizeDefinition, normalizeWrapper, os, readComponents, replaceBackSlashes, replaceConfigSlashes, replaceSlashes, setConfigDefaults, sysPath, warnAboutConfigDeprecations;

  exec = require('child_process').exec;

  http = require('http');

  fs = require('fs');

  os = require('os');

  sysPath = require('path');

  logger = require('loggy');

  SourceNode = require('source-map').SourceNode;

  readComponents = require('read-components');

  debug = require('debug')('brunch:helpers');

  commonRequireDefinition = require('commonjs-require-definition');

  require('coffee-script');

  exports.extend = extend = function(object, properties) {
    Object.keys(properties).forEach(function(key) {
      return object[key] = properties[key];
    });
    return object;
  };

  applyOverrides = function(config, options) {
    options.env.forEach(function(override) {
      var _ref;
      return deepExtend(config, ((_ref = config.overrides) != null ? _ref[override] : void 0) || {}, config.files);
    });
    return config;
  };

  deepExtend = function(object, properties, rootFiles) {
    if (rootFiles == null) {
      rootFiles = {};
    }
    Object.keys(properties).forEach(function(key) {
      var value;
      value = properties[key];
      if (toString.call(value) === '[object Object]' && object !== rootFiles) {
        if (object[key] == null) {
          object[key] = {};
        }
        return deepExtend(object[key], value, rootFiles);
      } else {
        return object[key] = value;
      }
    });
    return object;
  };

  exports.deepFreeze = deepFreeze = function(object) {
    Object.keys(Object.freeze(object)).map(function(key) {
      return object[key];
    }).filter(function(value) {
      return typeof value === 'object' && (value != null) && !Object.isFrozen(value);
    }).forEach(deepFreeze);
    return object;
  };

  exports.formatError = function(error, path) {
    return "" + error.code + " of '" + path + "' failed. " + (error.toString().slice(7));
  };

  exports.install = install = function(rootPath, command, callback) {
    var prevDir;
    if (callback == null) {
      callback = (function() {});
    }
    prevDir = process.cwd();
    logger.info("Installing " + command + " packages...");
    process.chdir(rootPath);
    return exec("" + command + " install", function(error, stdout, stderr) {
      var log;
      process.chdir(prevDir);
      if (error != null) {
        log = stderr.toString();
        logger.error(log);
        return callback(log);
      }
      return callback(null, stdout);
    });
  };

  exports.isWindows = isWindows = (function() {
    return os.platform() === 'win32';
  })();

  exports.replaceSlashes = replaceSlashes = function(_) {
    if (isWindows) {
      return _.replace(/\//g, '\\');
    } else {
      return _;
    }
  };

  exports.replaceBackSlashes = replaceBackSlashes = function(_) {
    if (isWindows) {
      return _.replace(/\\/g, '\/');
    } else {
      return _;
    }
  };

  exports.replaceConfigSlashes = replaceConfigSlashes = function(config) {
    var files;
    if (!isWindows) {
      return config;
    }
    files = config.files || {};
    Object.keys(files).forEach(function(language) {
      var lang, newJoinTo, order;
      lang = files[language] || {};
      order = lang.order || {};
      Object.keys(order).forEach(function(orderKey) {
        return lang.order[orderKey] = lang.order[orderKey].map(replaceSlashes);
      });
      switch (toString.call(lang.joinTo)) {
        case '[object String]':
          return lang.joinTo = replaceSlashes(lang.joinTo);
        case '[object Object]':
          newJoinTo = {};
          Object.keys(lang.joinTo).forEach(function(joinToKey) {
            return newJoinTo[replaceSlashes(joinToKey)] = lang.joinTo[joinToKey];
          });
          return lang.joinTo = newJoinTo;
      }
    });
    return config;
  };

  normalizeChecker = function(item) {
    switch (toString.call(item)) {
      case '[object RegExp]':
        return function(string) {
          return item.test(string);
        };
      case '[object Function]':
        return item;
      default:
        throw new Error("Config item " + item + " is invalid.Use RegExp or Function.");
    }
  };

  createJoinConfig = function(configFiles) {
    var joinConfig, listToObj, types;
    listToObj = function(acc, elem) {
      acc[elem[0]] = elem[1];
      return acc;
    };
    types = Object.keys(configFiles);
    joinConfig = types.map(function(type) {
      return configFiles[type].joinTo;
    }).map(function(joinTo) {
      var object;
      if (typeof joinTo === 'string') {
        object = {};
        object[joinTo] = /.+/;
        return object;
      } else {
        return joinTo;
      }
    }).map(function(joinTo, index) {
      var makeChecker, subConfig;
      makeChecker = function(generatedFilePath) {
        return [generatedFilePath, normalizeChecker(joinTo[generatedFilePath])];
      };
      subConfig = Object.keys(joinTo).map(makeChecker).reduce(listToObj, {});
      return [types[index], subConfig];
    }).reduce(listToObj, {});
    types.forEach(function(type) {
      return joinConfig[type].pluginHelpers = configFiles[type].pluginHelpers || (function() {
        var destFiles, joinMatch, nameMatch;
        destFiles = Object.keys(joinConfig[type]);
        joinMatch = destFiles.filter(function(file) {
          return joinConfig[type][file]('vendor/.');
        });
        if (joinMatch.length > 0) {
          return joinMatch[0];
        }
        nameMatch = destFiles.filter(function(file) {
          return /vendor/i.test(file);
        });
        if (nameMatch.length > 0) {
          return nameMatch[0];
        }
        return destFiles.shift();
      })();
    });
    return Object.freeze(joinConfig);
  };

  identityNode = exports.identityNode = function(code, source) {
    return new SourceNode(1, 0, null, code.split('\n').map(function(line, index) {
      return new SourceNode(index + 1, 0, source, line + '\n');
    }));
  };

  exports.cleanModuleName = cleanModuleName = function(path, nameCleaner) {
    return nameCleaner(path.replace(new RegExp('\\\\', 'g'), '/'));
  };

  getModuleWrapper = function(type, nameCleaner) {
    return function(fullPath, data, isVendor) {
      var moduleName, path, sourceURLPath;
      sourceURLPath = cleanModuleName(fullPath, nameCleaner);
      moduleName = sourceURLPath.replace(/\.\w+$/, '');
      path = JSON.stringify(moduleName);
      if (isVendor) {
        debug('Wrapping is vendor');
        return data;
      } else {
        if (type === 'commonjs') {
          return {
            prefix: "require.register(" + path + ", function(exports, require, module) {\n",
            suffix: "});\n\n"
          };
        } else if (type === 'amd') {
          return {
            data: data.replace(/define\s*\(/, function(match) {
              return "" + match + path + ", ";
            })
          };
        }
      }
    };
  };

  normalizeWrapper = function(typeOrFunction, nameCleaner) {
    switch (typeOrFunction) {
      case 'commonjs':
        return getModuleWrapper('commonjs', nameCleaner);
      case 'amd':
        return getModuleWrapper('amd', nameCleaner);
      case false:
        return function(path, data) {
          return data;
        };
      default:
        if (typeof typeOrFunction === 'function') {
          return typeOrFunction;
        } else {
          throw new Error('config.modules.wrapper should be a function or one of:\
"commonjs", "amd", false');
        }
    }
  };

  normalizeDefinition = function(typeOrFunction) {
    switch (typeOrFunction) {
      case 'commonjs':
        return function() {
          return commonRequireDefinition;
        };
      case 'amd':
      case false:
        return function() {
          return '';
        };
      default:
        if (typeof typeOrFunction === 'function') {
          return typeOrFunction;
        } else {
          throw new Error('config.modules.definition should be a function\
or one of: "commonjs", false');
        }
    }
  };

  exports.setConfigDefaults = setConfigDefaults = function(config, configPath) {
    var conventions, join, joinRoot, modules, overrides, paths, production, server, _base, _base1, _ref,
      _this = this;
    join = function(parent, name) {
      return sysPath.join(config.paths[parent], name);
    };
    joinRoot = function(name) {
      return join('root', name);
    };
    paths = config.paths != null ? config.paths : config.paths = {};
    if (paths.root == null) {
      paths.root = '.';
    }
    if (paths["public"] == null) {
      paths["public"] = joinRoot('public');
    }
    if (paths.watched == null) {
      paths.watched = ['app', 'test', 'vendor'].map(joinRoot);
    }
    if (paths.config == null) {
      paths.config = configPath != null ? configPath : joinRoot('config');
    }
    if (paths.packageConfig == null) {
      paths.packageConfig = joinRoot('package.json');
    }
    if (paths.bowerConfig == null) {
      paths.bowerConfig = joinRoot('bower.json');
    }
    conventions = config.conventions != null ? config.conventions : config.conventions = {};
    if (conventions.assets == null) {
      conventions.assets = /assets[\\/]/;
    }
    if (conventions.ignored == null) {
      conventions.ignored = (_ref = paths.ignored) != null ? _ref : function(path) {
        return sysPath.basename(path)[0] === '_';
      };
    }
    if (conventions.vendor == null) {
      conventions.vendor = /(^bower_components|vendor)[\\/]/;
    }
    if (config.notifications == null) {
      config.notifications = true;
    }
    if (config.sourceMaps == null) {
      config.sourceMaps = true;
    }
    if (config.optimize == null) {
      config.optimize = false;
    }
    if (config.plugins == null) {
      config.plugins = {};
    }
    modules = config.modules != null ? config.modules : config.modules = {};
    if (modules.wrapper == null) {
      modules.wrapper = 'commonjs';
    }
    if (modules.definition == null) {
      modules.definition = 'commonjs';
    }
    if (modules.nameCleaner == null) {
      modules.nameCleaner = function(path) {
        return path.replace(/^app\//, '');
      };
    }
    server = config.server != null ? config.server : config.server = {};
    if (server.base == null) {
      server.base = '';
    }
    if (server.port == null) {
      server.port = 3333;
    }
    if (server.run == null) {
      server.run = false;
    }
    overrides = config.overrides != null ? config.overrides : config.overrides = {};
    production = overrides.production != null ? overrides.production : overrides.production = {};
    if (production.optimize == null) {
      production.optimize = true;
    }
    if (production.sourceMaps == null) {
      production.sourceMaps = false;
    }
    if (production.plugins == null) {
      production.plugins = {};
    }
    if ((_base = production.plugins).autoReload == null) {
      _base.autoReload = {};
    }
    if ((_base1 = production.plugins.autoReload).enabled == null) {
      _base1.enabled = false;
    }
    return config;
  };

  warnAboutConfigDeprecations = function(config) {
    var ensureNotArray, messages, warnMoved, warnRemoved;
    messages = [];
    warnRemoved = function(path) {
      if (config.paths[path]) {
        return messages.push("config.paths." + path + " was removed, use config.paths.watched");
      }
    };
    warnMoved = function(configItem, from, to) {
      if (configItem) {
        return messages.push("config." + from + " moved to config." + to);
      }
    };
    warnRemoved('app');
    warnRemoved('test');
    warnRemoved('vendor');
    warnRemoved('assets');
    warnMoved(config.paths.ignored, 'paths.ignored', 'conventions.ignored');
    warnMoved(config.rootPath, 'rootPath', 'paths.root');
    warnMoved(config.buildPath, 'buildPath', 'paths.public');
    ensureNotArray = function(name) {
      if (Array.isArray(config.paths[name])) {
        return messages.push("config.paths." + name + " can't be an array.Use config.conventions." + name);
      }
    };
    ensureNotArray('assets');
    ensureNotArray('test');
    ensureNotArray('vendor');
    messages.forEach(logger.warn);
    return config;
  };

  normalizeConfig = function(config) {
    var mod, normalized;
    normalized = {};
    normalized.join = createJoinConfig(config.files);
    mod = config.modules;
    normalized.modules = {};
    normalized.modules.wrapper = normalizeWrapper(mod.wrapper, config.modules.nameCleaner);
    normalized.modules.definition = normalizeDefinition(mod.definition);
    normalized.conventions = {};
    Object.keys(config.conventions).forEach(function(name) {
      return normalized.conventions[name] = normalizeChecker(config.conventions[name]);
    });
    normalized.paths = {};
    normalized.paths.possibleConfigFiles = Object.keys(require.extensions).map(function(_) {
      return config.paths.config + _;
    }).reduce(function(obj, _) {
      obj[_] = true;
      return obj;
    }, {});
    normalized.paths.allConfigFiles = [config.paths.packageConfig, config.paths.bowerConfig].concat(Object.keys(normalized.paths.possibleConfigFiles));
    config._normalized = normalized;
    return config;
  };

  exports.loadConfig = function(configPath, options, callback) {
    var config, error, fullPath;
    if (configPath == null) {
      configPath = 'brunch-config';
    }
    if (options == null) {
      options = {};
    }
    try {
      fullPath = sysPath.resolve(configPath);
      fullPath = require.resolve(fullPath);
      delete require.cache[fullPath];
      config = require(fullPath).config;
    } catch (_error) {
      error = _error;
      if (configPath === 'brunch-config') {
        return exports.loadConfig('config', options, callback);
      } else {
        throw new Error("couldn\'t load config " + fullPath + ". " + error);
      }
    }
    setConfigDefaults(config, configPath);
    warnAboutConfigDeprecations(config);
    applyOverrides(config, options);
    deepExtend(config, options);
    replaceConfigSlashes(config);
    normalizeConfig(config);
    return readComponents('.', 'bower', function(error, bowerComponents) {
      var filesMap;
      if (error && !/ENOENT/.test(error.toString())) {
        logger.error(error);
      }
      if (bowerComponents == null) {
        bowerComponents = [];
      }
      config._normalized.bowerComponents = bowerComponents;
      filesMap = config._normalized.bowerFilesMap = {};
      bowerComponents.forEach(function(component) {
        var filesLength;
        filesLength = component.files.length;
        return component.files.forEach(function(file, index) {
          return filesMap[file] = component.sortingLevel + (filesLength * 0.001 - index * 0.001);
        });
      });
      deepFreeze(config);
      return callback(null, config);
    });
  };

}).call(this);
