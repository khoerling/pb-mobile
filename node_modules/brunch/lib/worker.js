// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var BrunchWorkers, cluster, debug, initWorker, numCPUs, origPipeline, pipeline, sysPath, workers,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  cluster = require('cluster');

  sysPath = require('path');

  numCPUs = require('os').cpus().length;

  debug = require('debug')('brunch:worker');

  pipeline = require('./fs_utils/pipeline');

  workers = void 0;

  origPipeline = pipeline.pipeline;

  pipeline.pipeline = function() {
    var args, callback, compilers, exts, linters, path, _ref, _ref1;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    path = args[0], linters = args[1], compilers = args[2], callback = args[3];
    exts = workers != null ? (_ref = workers.config) != null ? _ref.extensions : void 0 : void 0;
    if (workers && (!exts || (_ref1 = sysPath.extname(path).slice(1), __indexOf.call(exts, _ref1) >= 0))) {
      debug("Worker compilation of " + path);
      return workers.queue(path, function(_arg) {
        var msg;
        msg = _arg[0];
        msg.compiled = msg.data;
        return callback(msg.error, msg);
      });
    } else {
      return origPipeline.apply(null, args);
    }
  };

  initWorker = function(_arg) {
    var changeFileList, compilers, fileList, linters;
    changeFileList = _arg.changeFileList, compilers = _arg.compilers, linters = _arg.linters, fileList = _arg.fileList;
    fileList.on('compiled', function(path) {
      return process.send(fileList.files.filter(function(_) {
        return _.path === path;
      }));
    });
    return process.on('message', function(path) {
      return changeFileList(compilers, linters, fileList, path);
    }).send('ready');
  };

  BrunchWorkers = (function() {
    function BrunchWorkers(config) {
      var counter;
      this.config = config != null ? config : {};
      counter = this.count = this.config.count || numCPUs - 1;
      this.workerIndex = this.count - 1;
      this.jobs = [];
      this.list = [];
      while (counter--) {
        this.fork(this.list, this.work.bind(this));
      }
    }

    BrunchWorkers.prototype.fork = function(list, work) {
      return cluster.fork().on('message', function(msg) {
        var _ref;
        if (msg === 'ready') {
          this.handlers = {};
          list.push(this);
          return work();
        } else if (msg != null ? (_ref = msg[0]) != null ? _ref.path : void 0 : void 0) {
          return this.handlers[msg[0].path](msg);
        }
      });
    };

    BrunchWorkers.prototype.queue = function(path, handler) {
      this.jobs.push({
        path: path,
        handler: handler
      });
      return this.work();
    };

    BrunchWorkers.prototype.work = function() {
      var activeWorkers, _results;
      activeWorkers = this.list.length;
      if (!activeWorkers) {
        return;
      }
      if (activeWorkers < this.count) {
        if (this.jobs.length) {
          return this.next(activeWorkers - 1);
        }
      } else {
        _results = [];
        while (this.jobs.length) {
          this.next(this.workerIndex);
          if (++this.workerIndex === this.count) {
            _results.push(this.workerIndex = 0);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    BrunchWorkers.prototype.next = function(index) {
      var handler, path, _ref;
      _ref = this.jobs.shift(), path = _ref.path, handler = _ref.handler;
      this.list[index].handlers[path] = handler;
      return this.list[index].send(path);
    };

    return BrunchWorkers;

  })();

  module.exports = function(_arg) {
    var changeFileList, compilers, config, fileList, linters;
    changeFileList = _arg.changeFileList, compilers = _arg.compilers, linters = _arg.linters, fileList = _arg.fileList, config = _arg.config;
    if (cluster.isWorker) {
      debug('Worker started');
      initWorker({
        changeFileList: changeFileList,
        compilers: compilers,
        linters: linters,
        fileList: fileList
      });
      return void 0;
    } else {
      return workers = new BrunchWorkers(config.workers);
    }
  };

  module.exports.isWorker = cluster.isWorker;

  module.exports.close = cluster.disconnect;

}).call(this);
